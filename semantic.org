#+STARTUP: indent
* Semantic
** framework
#+begin_src python :tangle ${BUILDDIR}/semantic.py
  from typing import List, NewType, Union

  <<expression>>


  <<delimiter>>


  <<identifier>>


  <<literal>>


  <<call>>


  <<assignment>>


  <<fun>>


  <<var>>


  <<type>>


  <<union-type>>


  <<list-type>>


  <<map-type>>
#+end_src
** Expression
#+begin_src python :noweb-ref expression
  class Expression:
    pass

  class AndExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s and %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'AndExpression(%s, %s)' % (self.left, self.right)


  class OrExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s or %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'OrExpression(%s, %s)' % (self.left, self.right)


  class NotExpression(Expression):
    exp: Expression

    def __init__(self, exp: Expression = None):
      self.exp = exp

    def __str__(self):
      return 'not %s' % str(exp)

    def __repr__(self):
      return 'NotExpression(%s)' % (self.exp)


  class EqualsExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s == %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'EqualsExpression(%s, %s)' % (self.left, self.right)


  class NotEqualToExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s != %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'NotEqualToExpression(%s, %s)' % (self.left, self.right)


  class GreaterThanExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s > %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'GreaterThanExpression(%s, %s)' % (self.left, self.right)


  class GreaterThanOrEqualToExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s >= %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'GreaterThanOrEqualToExpression(%s, %s)' % (self.left, self.right)


  class LessThanExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s < %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'LessThanExpression(%s, %s)' % (self.left, self.right)


  class LessThanOrEqualToExpression(Expression):
    left: Expression
    right: Expression

    def __init__(self, left: Expression = None, right: Expression = None):
      self.left = left
      self.right = right

    def __str__(self):
      return '%s <= %s' % (str(self.left), str(self.right))

    def __repr__(self):
      return 'LessThanOrEqualToExpression(%s, %s)' % (self.left, self.right)
#+end_src
** Delimiter
#+begin_src python :noweb-ref delimiter
  class Delimiter:
    name: str

    def __init__(self, name: str = None):
      self.name = name

    def __str__(self):
      return self.name

    def __repr__(self):
      return 'Delimiter(%s)' % self.name
#+end_src
** Identifier
#+begin_src python :noweb-ref identifier
  class Identifier:
    name: str

    def __init__(self, name: str = None):
      self.name = name

    def __str__(self):
      return self.name

    def __repr__(self):
      return 'Identifier(%s)' % self.name
#+end_src
** Literal
#+begin_src python :noweb-ref literal
  class Literal(Expression):
    name: str
    type: str

    def __init__(self, name: str = None, type: str = None):
      self.name = name
      self.type = type

    def __str__(self):
      if self.type == 'char':
        return "'%s'" % self.name
      elif self.type == 'string':
        return '"%s"' % self.name
      else:
        return str(self.name)

    def __repr__(self):
      return 'Literal(%s: %s)' % (self.name, self.type)
#+end_src
** Call
#+begin_src python :noweb-ref call
  class Call(Expression):
    operator: Identifier
    operands: List[Union[Identifier, Literal]]
    type: str

    def __init__(self, operator: Identifier = None, operands: List[Union[Identifier, Literal]] = [], type: str = None):
      self.operator = operator
      self.operands = operands
      self.type = type

    def __str__(self):
      return '%s(%s)' % (str(self.operator), ', '.join([str(x) for x in self.operands]))

    def __repr__(self):
      return 'Call(%s: %s -> %s)' % (self.operator, self.operands, self.type)
#+end_src
** Assignment
#+begin_src python :noweb-ref assignment
  class Assignment:
    target: Identifier
    type: Identifier
    expression: Expression

    def __init__(self, target: Identifier = None, type: Identifier = None, expression: Expression = None):
      self.target = target
      self.type = type
      self.expression = expression

    def __str__(self):
      if self.type:
        return '%s : %s = %s' % (str(self.target), str(self.type), str(self.expression))
      else:
        return '%s = %s' % (str(self.target), str(self.expression))

    def __repr__(self):
      if self.type:
        return 'Assignment(%s: %s = %s)' % (self.target, self.type, self.expression)
      else:
        return 'Assignment(%s = %s)' % (self.target, self.expression)
#+end_src

** Fun
#+begin_src python :noweb-ref fun
  class Fun:
    names: List[Union[Identifier, Literal]]

    def __init__(self, name: Union[Identifier, Literal]):
      self.names = [name]

    def __str__(self):
      return ' '.join([str(x) for x in self.names])
#+end_src

** Var
#+begin_src python :noweb-ref var
  class Var:
    name: Identifier

    def __init__(self, name: Identifier = None):
      self.name = name

    def __str__(self):
      return str(self.name)
#+end_src

** Type
#+begin_src python :noweb-ref type
  class Type:
    kind: int

    def __init__(self, kind: int = 0, type = None):
      self.kind = kind
      self.type = type

    def __str__(self):
      return str(self.type)
#+end_src

** UnionType
#+begin_src python :noweb-ref union-type
  class UnionType():
    kind: int
    types: List[Type]

    def __init__(self):
      self.kind = 1
      self.types = []

    def __str__(self):
      return ' | '.join([str(x) for x in self.types])
#+end_src

** ListType
#+begin_src python :noweb-ref list-type
  class ListType():
    kind: int
    type: Type

    def __init__(self, type: Type = None):
      self.kind = 2
      self.type = type

    def __str__(self):
      return '[%s]' % str(self.type)
#+end_src

** MapType
#+begin_src python :noweb-ref map-type
  class MapType(Type):
    kind: int
    keytype: Type
    valtype: Type

    def __init__(self, keytype: Type = None, valtype: Type = None):
      self.kind = 3
      self.keytype = keytype
      self.valtype = valtype

    def __str__(self):
      return '{%s: %s}' % (str(self.keytype), str(self.valtype))
#+end_src
