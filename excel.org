#+STARTUP: indent
* Excel
** framework
#+begin_src python :tangle ${BUILDDIR}/excel.py
  from typing import List, Mapping, Tuple, Union
  from model import Event, Parameter, State, Transaction, Variable
  from semantic import Assignment, Call, Expression, Identifier
  from analyzer import Lexer, ParameterSyntaxer, ParameterLexerAdapter
  import re

  <<importer>>

  <<exporter>>
#+end_src
** importer
*** basic
#+begin_src python :noweb-ref importer
  <<parse-events>>

  <<parse-states>>

  def load(src: str) -> List[Event]:
    from openpyxl import load_workbook
    wb = load_workbook(src, read_only = True)
    wx = wb[wb.sheetnames[0]]
    events = _parse_events(wx)
    states = _parse_states(wx, events)
    wb.close()
    return states
#+end_src

*** parse events
#+begin_src python :noweb-ref parse-events
  <<verify-parameter>>

  <<verify-event>>

  def _parse_events(wx) -> List[Tuple[Event, str]]:
    uniqevents = {}
    events = []
    headers = wx[1]
    for i in range(1, len(headers)):
      header = headers[i]
      if not header.value:
        continue
      guard = None
      parameters = []
      result = re.search('(.*)\((.*)\)\[(.*)\]', header.value)
      if result:
        eventname = result.group(1).strip()
        guard = result.group(3).strip()

        syntaxer = ParameterSyntaxer()
        lexer = Lexer(ParameterLexerAdapter(syntaxer))
        for ch in result.group(2):
          lexer.feed(ch)
        lexer.eof()
        syntaxer.eof()
        parameters = syntaxer.result()
      else:
        result = re.search('(.*)\((.*)\)', header.value)
        if result:
          eventname = result.group(1).strip()
          syntaxer = ParameterSyntaxer()
          lexer = Lexer(ParameterLexerAdapter(syntaxer))
          for ch in result.group(2):
            lexer.feed(ch)
          lexer.eof()
          syntaxer.eof()
          parameters = syntaxer.result()
        else:
          eventname = header.value.strip()
      if eventname not in uniqevents:
        event = Event()
        event.name = eventname
        for parameter in parameters:
          event.parameters.append(_verify_parameter(parameter, header))
        uniqevents[eventname] = event
      else:
        event = uniqevents[eventname]
      events.append((_verify_event(event, header), guard))
    return events
#+end_src
**** verify-parameter
#+begin_src python :noweb-ref verify-parameter
  def _verify_parameter(p: Parameter, d) -> Parameter:
    if not p.name:
      print('Missing name in parameter: %s' % d)
      exit(1)
    if not p.type:
      print('Missing type in parameter: %s' % d)
      exit(1)
    return p
#+end_src
**** verify-event
#+begin_src python :noweb-ref verify-event
  def _verify_event(e: Event, d) -> Event:
    if not e.name:
      print('Missing name in event: %s' % d)
      exit(1)
    else:
      return e
#+end_src
*** parse states
#+begin_src python :noweb-ref parse-states
  <<verify-transaction>>

  def _parse_states(wx, headers: List[Tuple[Event, str]]) -> List[State]:
    states = []
    variables = {}
    isheader = True
    for row in wx.rows:
      if isheader:
        isheader = False
        continue
      state = State()
      if row[0].value.count('.') != 0:
        continue
      state.name = row[0].value
      for j in range(1, len(row)):
        transaction = Transaction()
        transaction._targetstr = None
        cell = row[j]
        if cell.value:
          transaction.event = headers[j - 1][0]
          transaction.guard = headers[j - 1][1]
          lines = cell.value.split('\n')
          state_mode = False
          for line in lines:
            if line == '----':
              state_mode = True
              continue
            if not state_mode:
              matched = re.search('(.*):(.*)=(.*)', line)
              if matched:
                varname = matched[1].strip()
                vartype = matched[2].strip()
                exp = matched[3].strip()
                var = Variable(varname, vartype)
                variables[var.name] = var
                assignment = Assignment(Identifier(varname), Identifier(vartype), exp)
                transaction.actions.append(assignment)
                continue
              matched = re.search('(.*)\((.*)\)', line)
              if matched:
                call = Call(Identifier(matched[1].strip()), [], None)
                call._operandstrs = [x.strip() for x in matched[2].split(',')]
                transaction.actions.append(call)
                continue
              else:
                if len(line) == 0:
                  continue
                call = Call(Identifier(line), [], None)
                call._operandstrs = None
                transaction.actions.append(call)
            else:
              transaction._targetstr = line
          state.transactions.append(transaction)
      states.append(state)
    for state in states:
      for t in state.transactions:
        _verify_transaction(t, states)
    return ([x for x in variables.values()], states)
#+end_src
**** verify transaction
#+begin_src python :noweb-ref verify-transaction
  def _verify_transaction(t: Transaction, states: List[State]):
    if t._targetstr:
      for state in states:
        if t._targetstr == state.name:
          t.target = state
          break
      if not t.target:
        print('Undefined target: %s' % t._targetstr)
        exit(1)
    if len(t.actions) > 0:
      for action in t.actions:
        if isinstance(action, Assignment):
          pass
        elif isinstance(action, Call):
          if action._operandstrs:
            args = []
            for arg in action._operandstrs:
              found: bool = False
              for param in t.event.parameters:
                if arg == param.name:
                  args.append(Identifier(arg))
                  found = True
                  break
              if not found:
                print('Undefined action arguments "%s" in action: %s' % (arg, action))
                exit(1)
            action.operands = args
#+end_src
** exporter
*** basic
#+begin_src python :noweb-ref exporter
  <<export-headers>>

  <<export-content>>

  def save(dst: str, variables: List[Variable], states: List[State]):
    from openpyxl import Workbook
    from openpyxl.styles import NamedStyle, Border, Side
    import os.path
    if dst.endswith('excel'):
      dst = dst[:-5] + 'xlsx'

    wb = Workbook(write_only = True)
    ws = wb.create_sheet()
    pairs = {}
    idx = 0
    for state in states:
      for transaction in state.transactions:
        event = transaction.event
        key = str(event) + str(transaction.guard)
        if key not in pairs:
          pairs[str(event) + str(transaction.guard)] = (idx, event, transaction.guard)
          idx += 1
    headers = [x for x in pairs.values()]
    headers.sort()
    _export_headers(ws, headers)
    rows = []
    for state in states:
      row = [state]
      for (_, event, guard) in headers:
        found = False
        for transaction in state.transactions:
          if event == transaction.event and (str(guard) == str(transaction.guard)):
            row.append((transaction.target if transaction.target != state else None, transaction.actions))
            found = True
            break
        if not found:
          row.append((None, None))
      rows.append(row)
    _export_content(ws, rows)
    wb.save(dst)
#+end_src
*** export headers
#+begin_src python :noweb-ref export-headers
  def _export_headers(ws, values: List[Tuple[int, Event, Expression]]):
    headers = []
    for (_, event, guard) in values:
      header = ''
      if len(event.parameters) > 0:
        header += '%s(%s)' % (event.name, ', '.join(['%s: %s' % (x.name, x.type) for x in event.parameters]))
      else:
        header += '%s' % (event.name)
      if guard:
        header += '[%s]' % str(guard)
      headers.append(header)
    ws.append(['state\event'] + headers)
#+end_src
*** export content
#+begin_src python :noweb-ref export-content
  def _export_content(ws, values: List[List[Union[State, Tuple[State, List[Union[Assignment, Expression]]]]]]):
    for line in values:
      row = []
      for cell in line:
        if isinstance(cell, State):
          row.append(cell.name)
        elif isinstance(cell, tuple):
          (state, actions) = cell
          content = ''
          if actions:
            tmp = []
            for x in actions:
              if isinstance(x, Assignment):
                tmp.append('%s: %s = %s' % (str(x.target), str(x.type), str(x.expression)))
              else:
                tmp.append(str(x).replace('()', ''))
            content += '\n'.join(tmp)
          content += '\n----\n'
          if state:
            content += state.name
          if content == '\n----\n':
            content = None
          row.append(content)
      ws.append(row)
#+end_src
